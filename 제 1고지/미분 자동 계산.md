# **제 1고지** 미분 자동 계산
지금부터 시작되는 제 1고지는 총 10단계로 구성됩니다. 여기에선 미분을 자동으로 계산하는 틀을 만듭니다. 미분을 자동으로 계산하기 위해 '변수'와 '함수'를 표현하는 두 클래스 Variable과 Function을 만듭니다.

## **1단계** 상자로서의 변수
### 1.1 변수란?
프로그래밍 입문서에선 상자에 데이터를 넣는 그림을 보여주며 '상자'가 변수라고 설명한다. 이런 설명을 정리하면 아래와 같다.
* 상자(변수)와 데이터는 별개다.
* 상자(변수)에는 데이터가 들어간다. => **대입** 또는 **할당**
* 상자(변수)를 들여다보면 데이터를 알 수 있다. => **참조**

### 1.2  Variable 클래스 구현
변수는 영어로 Variable이라 한다. 따라서, 변수라는 개념을 Variable 이라는 이름의 클래스로 구현하도록 하자. 아래는 이 기능이 최소한으로 구현된 모습이다.
```python
class Variable:
    def __init__(self, data):
        self.data = data
```

참고) 파이썬이 권장하는 코딩 규칙 <a href="https://www.pyton.org/dev/peps/pep-0008">PEP8</a>

### 1.3 [보충] 넘파이의 다차원 배열
다차원 배열에서는 원소의 순서에 방향이 있고, 이 방향을 **차원(dimension)** 혹은 **축(axis)** 이라 한다. 0차원 배열, 1차원 배열, 2차원 배열을 각각 **스칼라(scalar)**, **벡터(vector)**, **행렬(matrix)** 이라 한다. 다차원 배열을 **텐서(tensor)** 로 부르기도 한다. 

## **2단계** 변수를 낳는 함수
앞 단계에서 Variable 클래스를 상자로 사용할 수 있도록 하였다. 그러나 지금은 단순한 상자일 뿐이다. 따라서 우리는 단순한 상자를 마법의 상자로 바꾸는 장치가 필요하고 이를 '함수'라 한다. 

### 2.1 함수란?
함수를 딱딱하게 표현하면 *'어떤 변수로부터 다른 변수로의 대응 관계를 정한 것'*이라 할 수 있다. 변수 $x$와 $y$, 그리고 함수 $f$의 관계를 그림으로 나타낼 수 있다. 원과 사각형모양의 노드를 화살표로 연결해 계산 과정을 표현한 그림을 **계산 그래프(computational graph)** 라 한다. 

### 2.2 Function 클래스 구현
앞서 구현한 Variable 인스턴스를 변수로 다룰 수 있는 함수를 Function 클래스로 구현한다. 이 때, 주의할 점은 2가지이다.
* Function 클래스는 Variable 인스턴스를 입력받아 Variable 인스턴스를 출력한다.
* Variable 인스턴스의 실제 데이터는 인스턴스 변수인 data에 있다.

위 두 가지에 유의하며 Function 클래스를 아래와 같이 구현한다.
``` python
class Function:
    def __call__(self, input: Variable):
        x = input.data # 데이터를 꺼낸다.
        y = x ** 2 # 실제 계산
        output = Variable(y) # 계산 결과를 Variable의 형태로 만든다.
        return output
```
<p> __call__ 메소드의 인수 input은 Variable 인스턴스라 가정하고 데이터를 꺼내 원하는 계산을 한 뒤 결과를 Varable이라는 '상자'에 담아 돌려준다. </p>

### 2.3 Function 클래스의 이용
Function 클래스를 실제로 사용해보도록 하자. 

```python
x = Variable(np.array(10))
f = Function()
y = f(x)

print(type(y)) # type() 함수는 객체의 클래스를 알려준다.
print(y.data)
```
실행 결과
```
<class '__main__.Variable'>
100
```
이와 같이 Variable과 Function을 연계할 수 있다. 실행 결과를 보면 y의 클래스는 Variable이고, 데이터는 y.data에 잘 저장되었음을 확인할 수 있다.

그러나 방금 구현한 Function 클래스의 용도는 '입력값의 제곱'으로 고정된 함수이다. 따라서 Sqaure라는 이름이 더 어울린다. 앞으로 여러 기능을 하는 함수가 필요하다는 점을 고려하면 Function 클래스는 기반 클래스로 두고 모든 함수가 공통적으로 제공하는 기능만 담아두는 것이 좋다. 그래서 앞으로 모둔 함수는 다음의 두 사항을 충족하도록 구현하자.
* Function 클래스는 기반 클래스로서, 모든 함수에 공통되는 기능을 구현한다.
* 구체적인 함수는 Function 클래스를 상속한 클래스에서 구현한다.

이를 위해 Function 클래스를 아래와 같이 수정한다.
``` python
class Function:
    def __call__(self, input: Variable):
        x = input.data
        y = self.forward(x)
        output = Variable(y)
        return output
    
    def forward(self, x: Variable):
        raise NotImplementedError()
```
<p> __call__ 메서드를 살짝 수정하고 forward라는 메서드를 추가하였다. __call__ 메서드는 Variable에서 데이터를 가져오고, 계산 결과를 Variable에 포장하는 두 가지 일을 한다. 구체적인 계산은 forward를 호출하여 수행한다. forward 메서드의 구체적인 로직은 하위 클래스에서 구현 하도록 한다. </p>

```
Funtion클래스의 forward 메서드는 예외를 발생시킨다. 따라서 Function 클래스의 forward 메서드를 직접 호출한 사람에게 '이 메서드는 상속해 구현해야 한다.'는 사실을 알려줄 수 있다.
```
이어 Function 클래스를 상속하여 입력값을 제곱하는 클래스를 구현하도록 하자. 클래스의 이름은 Square라 짓고 다음과 같이 구현한다.

``` python
class Square(Function):
    def forward(self, x):
        return x ** 2
```

<p> Square 클래스는 Function 클래스를 상속하기 때문에 __call__ 메서드는 그대로 계승된다. 따라서 forward 메서드에 구체적인 계산 로직을 작성해 넣는 것 만으로 구현은 끝이 난다. </p>

## **3 단계** 함수 연결
이번 단계에서는 또 다른 함수를 구현하고 여러 함수를 조합해 계산할 수 있도록 하겠다.

### 3.1 Exp 함수 구현
$y=e^{x}$를 계산하는 함수를 구현하도록 하겠다. 여기서 $e$는 자연로그의 밑(base of the natural lograithm)이다. 오일러 수 네이피어 상수라고도 한다. 구현은 아래와 같다.
```python
class Exp(Function):
    def forward(self, x):
        return np.exp(x)
```

### 3.2 함수 연결
Function 클래스의 ```__call__``` 메서드는 입력과 출력이 모두 Variable 인스턴스이므로 자연스럽게 함수를 연이어 사용할 수 있다. $y=(e^{x^{2}})^{2}$이라는 계산을 예로 생각할 수 있다.
```python
A = Square()
B = Exp()
C = Square()

x = Variable(np.array(0.5))
a = A(x)
b = B(a)
y = C(b)
print(y.data)
```
**실행 결과**
```
1.648721270700128
```
3개의 함수 A, B, C를 연이어 적용했다. 여기서 중요한 점은 중간에 등장하는 4개의 변수(x, a, b, y)는 모두 Variable 인스턴스라는 점이다. Function 클래스의 ```__call__```메서드의 입출력이 Variable 인스턴스로 통일되어있어 여러 함수를 연속하여 적용할 수 있다. ```C(B(A(x)))```처럼도 가능하다는 것이다. 일련의 계산 과정을 '계산 그래프'로 표현할 수 있는데, 계산 그래프를 이용하면 각 변수에 대한 미분을 효율적으로 계산할 수 있다. 변수별 미분을 계산하는 알고리즘이 역전파(backpropagation)이다. 다은 단계부터 이 역전파를 구현해보도록 하자.

## **4 단계** 수치 미분
지금까지 Variable 클래스와 Function 클래스를 구현했다. 이 클래스들을 구현한 이유는 미분을 자동으로 계산하기 위해서이다. 이번 단계에서는 미분이 무엇인지와 수치 미분이라는 간단한 방법으로 미분을 계산해보도록 하겠다. 그 다음 5단계에서 수치 미분을 대신하는 더 효율적인 알고리즘(역전파)를 구현할 계획이다.
```
머신러닝 외에 유체 역학, 금융 공학, 기상 시뮬레이션, 엔지니어링 설계 최적화 등 많은 분야에서 미분을 활용한다.
```

### 4.1 미분이란?
미분이 무엇일까? 쉽게 얘기하면 _'변화율'_을 뜻한다. 정확한 정의는 '극한으로 짧은 시간'에서의 변화량을 뜻한다. 이를 수식으로 표현하면 함수 $f(x)$가 있을 때 미분은 다음과 같이 정의 된다.
<var id="exp_4_1"> $$f'(x) = \lim_{h \rightarrow 0}{{f(x+h) - f(x)} \over {h}}$$</var>
만약 $x = a$ ($a$는 상수)일 때의 값을 점 $a$에 대한 $f(x)$의 **미분**이라 한다. $y=f(x)$가 어떤 구간에서 미분 가능하다면 [[식4.1]](#exp_4_1)은 해단 구간의 '모든 $x$'에 대해 성립한다. 따라서 [[식 4.1]](#exp_4_1)의 $f'(x)$도 함수이고, $f(x)$의 **도함수**라 한다.

### 4.2 수치 미분 구현
그럼 미분을 정의한 [[식 4.1]](#exp_4_1)에 따라 미분을 계산하는 코드를 구현해 보자. 그러나 컴퓨터는 극한을 취급할 수 없으니 $h$를 극한과 비슷한 매우 작은 값으로 대체할 수 있다. 이런 미세한 차이를 이용해 함수의 변화량을 구하는 방법을 **수치 미분(numerical differentiation)** 라 한다. 따라서 값에 약간의 오차가 생기는데 이 근사 오차를 줄이는 방법으로는 
**중앙 차분(centered differentiation)** 이라는 것이 있다. 중앙 차분은 $f(x + h) - f(x)$를 구하는 대신 $f(x + h) - f(x - h)$의 차이를 구한다. $f(x + h) - f(x)$를 이용해 기울기를 구하는 방법을 **'전진 차분(forweard difference)'** 라 하는데 중앙차분 쪽이 상대적으로 오차가 적다. 이는 테일러 급수를 이용해 중앙차분이 전진차분에 비해 실제 미분값과 가깝다는 것을 증명할 수 있다. 이제 중앙차분을 이용한 수치 미분 계산 함수 numerical_diff(f, x, eps=1e-4)를 구현해보도록 하자. 첫 번째 인수는 미분의 대상이 되는 함수이고, 두 번째 인수 x는 미분을 계산하는 변수이며, 마지막 eps는 작은 값을 나타내고 기본적으로 1e-4이다. 수치 미분은 아래와 같이 구현될 수 있다.
```python
def numerical_diff(f: Function, x: Variable, eps=1e-4):
    x0 = Variable(x.data - eps)
    x1 = Variable(x.data + eps)
    y0 = f(x0)
    y1 = f(x1)
    return (y1.data - y0.data) / (2 * eps)
```
아래는 3 단계에서 구현한 Square 클래스를 대상으로 미분한 것이다.
```python
f = Square()
x = Variable(np.array(2.0))
dy = numerical_diff(f, x)
print(dy)
```
실행 결과
```
4.000000000004
```
이렇게 함수 $y=x^{2}$에서 $x=2.0$일 때, 수치 미분한 결과를 구했다. 오차가 없으면 4.0이므로 이 결과는 거의 올바르다 할 수 있다.

참고) Todd Young, Marint J. Mohlenkamp. "[Introduction to Numerical Methods and Matlab Programming for Engineers](http://www.ohiouniversityfaculty.com/youngt/IntNumMeth/book.pdf) - Lecture 27: Numerical Differentiation" (2019.11)

### 4.3 합성 함수의 미분
지금까지는 $y=x^{2}$이라는 단순한 함수를 다뤘다. 이어 합성함수를 미분해보도록 하자. $y=(e^{x^{2}})^{2}$이라는 계산에 대한 미분 ${dy}\over{dx}$를 계산할 것이다. 코드는 다음과 같다.
```python
def f(x):
    A = Square()
    B = Exp()
    C = Square()
    return C(B(A(x)))

x = Variable(np.array(0.5))
dy = numerical_diff(f, x)
print(dy)
```
실행 결과
```
3.2974426293330694
```
이상으로 미분을 '자동'으로 계산하는 데 성공하였다. 위 합성 함수 $f$의 해석학적인 미분은 $4xe^{2x^{2}}$ 이다. $x=0.5$에서의 미분은 $2e^{0.5}$이므로 약 ```3.2974425414002564```이다. 따라서 위 계산과 오차가 거의 나지 않음을 확인 할 수 있다. 이 방식으로 아무리 복잡하게 조합된 함수여도 미분을 자동으로 계산할 수 있다. 그러나 안타깝게도 이 수치 미분에는 문제가 있다.

### 4.4 수치 미분의 문제점
위에서 여러번 살펴봤듯 수치 미분의 결과에는 항상 오차가 포함되어 있다. 대부분의 경우 오차는 매우 작지만 어떤 계산을 하냐에 따라 커질 수도 있다. 또, 수치 미분의 더 심각한 문제는 계산량이 많다는 점이다. 변수가 여러 개인 계산을 미분할 경우 변수 각각을 미분하여야한다. 신경망에선 매개변수를 수백만 개 이상 사용하는건 일도 아니므로 이 모두를 수치 미분하는 것은 현실적이지 못하다. 그래서 등장한 것이 역전파이다. 다음 단계에서 드디어 역전파를 소개한다.

수치 미분은 구현하기 쉽고 거의 정확한 값을 얻을 수 있다. 이에 비해 역전파는 알고리즘이 복잡하여 구현하면서 버그가 섞여 들어가기 쉽다. 그래서 역전파를 정확하게 구현했는지 확인하기 위해 수치 미분의 결과를 이용하곤 한다. 이를 **기울기 확인(gradient checking)** 라 하는데, 단순히 수치 미분 결과와 역전파의 결과를 비교하는 것이다. 기울기 확인은 10 단계에서 구현하기로 하자.
